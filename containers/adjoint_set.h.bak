#ifndef ADJOINT_SET_H
#define ADJOINT_SET_H

#include <algorithm>
#include <cassert>
#include <chrono>
#include <iostream>
#include <limits>
#include <random>
#include <vector>

class AdjointSet {
  public:
    class Node {
      public:
        size_t next_id;
        size_t prev_id;
    };
    static const size_t NONE;
    size_t n;
    size_t k;
    size_t seed;
    std::vector<Node> data;
    std::vector<size_t> first;
    std::vector<size_t> last;
    std::vector<size_t> size;
    std::vector<size_t> which_cluster;
    template <typename T1, typename T2>
    AdjointSet(size_t _n, size_t _k, T1 which_cluster_begin,
               T2 which_cluster_end)
        : n(_n), k(_k), data(n), first(k, NONE), last(k, NONE), size(k, 0),
          which_cluster(which_cluster_begin, which_cluster_end) {
        assert(n != NONE);
        initial();
    }
    // random initial with given seed
    AdjointSet(size_t _n, size_t _k, size_t _seed)
        : n(_n), k(_k), seed(_seed), data(n), first(k, NONE), last(k, NONE),
          size(n, 0), which_cluster(_n) {
        assert(n != NONE);
        random_assign();
        initial();
    }
    AdjointSet(size_t _n, size_t _k)
        : n(_n), k(_k),
          seed(std::chrono::system_clock::now().time_since_epoch().count()),
          data(n), first(k, NONE), last(k, NONE), size(n, 0),
          which_cluster(_n) {
        seed = 1460625373037597;
        assert(n != NONE);
        random_assign();
        initial();
    }
    void initial() {
        for (size_t vid = 0; vid < n; vid++) {
            size_t cid = which_cluster[vid];
            insert(vid, cid);
        }
    }
    inline bool empty(size_t cid) { return last[cid] == NONE; }

    inline void insert(size_t vid, size_t cid) {
        size[cid]++;
        if (empty(cid)) {
            first[cid] = vid;
            last[cid] = vid;
            data[vid].prev_id = NONE;
            data[vid].next_id = NONE;
        } else {
            size_t last_id = last[cid];
            auto &last_node = data[last_id];
            auto &new_node = data[vid];
            last_node.next_id = vid;
            new_node.prev_id = last_id;
            new_node.next_id = NONE;
            last[cid] = vid;
        }
    }
    void print();

    inline size_t begin(size_t cid) { return first[cid]; }

    inline size_t end() { return NONE; }

    inline bool not_end(size_t vid) { return vid != NONE; }

    inline size_t next(size_t &vid) { return data[vid].next_id; }
    // append cid2 to cid1
    void merge(size_t cid1, size_t cid2) {
        if (cid1 > cid2) {
            std::swap(cid1, cid2);
        }

        if (empty(cid2)) {
            return;
        }

        size[cid1] += size[cid2];
        size[cid2] = 0;

        size_t vid = first[cid2];
        while (vid != NONE) {
            which_cluster[vid] = cid1;
            vid = next(vid);
        }

        size_t first_cid2_index = first[cid2];
        size_t last_cid1_index = last[cid1];
        first[cid2] = NONE;
        data[last_cid1_index].next_id = first_cid2_index;
        data[first_cid2_index].prev_id = last_cid1_index;

        size_t last_cid2_index = last[cid2];
        last[cid2] = NONE;
        last[cid1] = last_cid2_index;
    }

    void random_assign() {
        std::vector<size_t> vertice(n);
        for (size_t i = 0; i < n; i++) {
            vertice[i] = i;
        }
        // shuffle(vertice.begin(), vertice.end(),
        //         std::default_random_engine(seed));
        for (size_t i = 0; i < n; i++) {
            which_cluster[i] = vertice[i] % k;
        }
    }

    void move(size_t vid, size_t cid) {
        if (which_cluster[vid] == cid) {
            return;
        }
        size_t old_cid = which_cluster[vid];
        which_cluster[vid] = cid;
        size[old_cid]--;
        size[cid]++;
        size_t prev_id = data[vid].prev_id;
        size_t next_id = data[vid].next_id;
        if (prev_id != NONE) {
            data[prev_id].next_id = next_id;
        } else {
            first[old_cid] = next_id;
        }
        if (next_id != NONE) {
            data[next_id].prev_id = prev_id;
        } else {
            last[old_cid] = prev_id;
        }
        data[vid].next_id = NONE;
        data[vid].prev_id = last[cid];
        data[last[cid]].next_id = vid;
        last[cid] = vid;
    }
};

const size_t AdjointSet::NONE = std::numeric_limits<std::size_t>::max();

#endif
